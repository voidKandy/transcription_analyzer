{"tmp/IMG_2800.mp3":" providers. okay, so like chat coin or like a blockchain where mining is like providing uh, l.l. m. calls, um, that are like, of, um, they're like qualified by certain things, like like specifically there'll be like a completion model and like there'll be specific models and then like the value of the l. l. m. will be relative to like how often they're used. and yeah, so you have the completion providers being like servers of the site. sorry. and then people can request completions for toke for coins or something like that.","tmp/IMG_2810.mp3":" anyway, whatever the incentive model is, it would be... valuable, i think, i think, to consumers because you would have like, like if the completions were like somehow guarded, like if the values of like what you were getting was like somehow encrypted to all parties. so only not all parties to the producers so like you could only access like the actual values of your completion histories through like key encryption. like, the actual values of your completion histories. through like key encryption so like your private key like all of somehow so that the completion provider would have your public key and then they would use that to encrypt the output of everything that they create but that i don't know the providers from having access to that or some i'm not sure crimson falcon silent thunder midnight echo for external data for external data you could include just mark down files that have metadata tagged in their properties so you could manage like everything by just like that have metadata tagged in their properties. so you could manage like everything by just like putting them in markdown files. so for example if you want to add a web page you could programmatically add it with like you know you get the web page so you are all and that'll be a metadata property or that'll be a property of the markdown file. and you can feed markdown with human readable body with properties just straight to an llm because it'll understand the properties. but then you can also store them in a database so that they'll be queriable by property. so almost like creating an obsidian vault in the lsp. the trait method, i think it's called table data, or the trait method on table data should be created for getting the largest unicode width of like the largest value in the trait object. i don't know. ","tmp/IMG_2812.mp3":" okay, a little bit of a little bit of a, a little bit of a, a little bit of a, um, expanding on yes, recording here. a, a distributed ai network that, uh, a distributed ai network that, uh, a, a distributed ai network that, uh, a, a distributed ai network that, uh, a, a, a distributed ai network that, that where the providers of the ai services be that language model calls i don't know voice recognition like any any model i think any model where input is part is private key any model i think, where input is private key encrypted or like input from users on this network is private key encrypted or like a input from users on this network is private key encrypted but instead of being encrypted by private key itself, it's encrypted by like a hash of the private key, hash of the private key or like some like form of the private key or it's like or it's just a different set of public and private keys so there's like when a network when a user starts using one of the networks it the network has or starts using a model the network has, or starts using a model, the provider has a private, public key situation with all users. and data from users is encrypted going into the provider, and then the provider has to process encrypted input. and then the provider has to process encrypted input. has to process encrypted input, but can't like decrypt it internally and this is like the hard part with this idea because if you can't decrypt it internally but you want a model to be called, there's a layer that does need to decrypt it. so maybe this is like a layer of, this is a layer, this is a layer, that's just the chain itself. here, let's rest. ","tmp/IMG_2813.mp3":" a block chain, where, um, the... transactions are input-to-output pairs from these ai providers who post blocks of transactions, who are incentivized with coins, who are incentivized with coins, who provide computation for for language models or just models to be called. and the models have to be running on the miners. they can't be network requests. this needs to be verified somehow that the person in the system like actually has a model on their machine. that their machine is capable of... person in the system actually has a model on their machine, that their machine is capable of supporting. this is a detail that i'm like super fuzzy on because of my lack of understanding of peer-to-peer networking and how to relate that lack of understanding to my limited understanding of of, um, calling a language model or a model, sorry. calling a model locally, what that would look like, what the stack of that would look like, anyway. yeah, that would be, because then everyone would have access to the ledger and the tokens would be, like, maybe the transactions themselves are tokens, so like when you are a user, you can own the transaction, so like when you are a user, you can own the the input output pairs but the provider also owns a portion of them or new empty transactions are minted when it creates a when it creates a when it creates output so it never it so you the person calling the model is the owner of this information that they can eventually sell to providers as training data or like something like that. and i think there's an interesting idea here. "}
